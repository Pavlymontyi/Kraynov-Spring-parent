Глава 5 - Детальные сведения о конфигурации Spring

Редактор свойств для компонентов JavaBean
com.kraynov.ch5.propeditors.*
  Так как изрядная часть значений свойств в Spring-приложении задается в файле конфигурации BeanFactory (?), в сущности,
  эти свойства являются строками. Поэтому платформа спринг позволяет определить редакторы свойств, которые будут управлять
  преобразованием значений String в подходящие типы (при инжекте этих свойств в бин). Другими словами, разработчик может
  прописывать в файле конфигурации строковые значения, а специальные классы - редактооы свойств - будут трансформировать
  эти строки в объекты, такие как Locale, Pattern, Date и тд.
  В Spring 3.1 доступно 13 встроенных реализаций PropertyEditor (стандартный интерфейс, который преобразует значения
  свойства в/из внутреннего представления типа String). Класс com.kraynov.ch5.propeditors.PropertyEditorBean содержит 13 свойств, по
  одному на каждый тип. Конфигурация для этого класса содержится в файле builtin.xml: по умолчанию CustomDateEditor и
  StringTrimmerEditor не зарегистрированы в Spring, поэтому для них мы вручную прописываем регистрацию.
 Создание специального редактора свойств
  Иногда возникает потребность в создании собственного редактора свойств. PropertyEditor содержит большое количество
  методов, которые нужно реализовать. JDK5+ предлагает решить эту проблему путем расширения класса PropertyEditorSupport,
  который оставляет за нами реализацию только одного метода setAsText().
  Примером реализации кастомного редактора свойств является класс com.kraynov.ch5.propeditors.NamePropertyEditor, который преобразует
  строку с разделителем-пробелом в имя и фамилию для класса com.kraynov.ch5.propeditors.Name. Чтобы использовать кастомный редактор
  свойств, нужно зарегистрировать его в ApplicationContext. Конфигурация приведена в custom.xml.
  Регистрация редактора свойст осуществляется путем установки свойства customEditors для бина, который является инстансом
  класса org.springframework.beans.factory.config.CustomEditorConfigurer (имя бина неважно).

Дополнительные сведения о конфигурации ApplicationContext
  Помимо функций, определенных в BeanFactory, класс ApplicationonContext предлагает и другую функциональность. Самым
  главным преимуществом является возможность конфигурировать и управлять ресурсами полностью декларативным путем. Другими
  полезными функциями являются:
       интернационализация;
       публикация событий;
       управление и доступ к ресурсам;
       доп. интерфесы жизненного цикла;
       улучшенное автоматическое конфигурирование компонент инфраструктуры.

 Интернационализация с помощью интерфейса MessageSource - com.kraynov.ch5.context.MessageSourceDemo
  Используя интерфейс org.springframework.context.MessageSource приложение может получить доступ к строковым ресурсам,
  называемым сообщениями, которые сохранены для множества разных языков. Чтобы получить поддержку MessageSource,
  предлагаемую ApplicationContext, в конфигурации понадобится определить бин типа MessageSource с именем messageSource.
  Простейший пример использования приведен в классе MessageSourceDemo.
 События приложений - com.kraynov.ch5.event.*
  ApplicationContext можно использовать в качестве брокера сообщений. Событие это класс, производный от ApplicationEvent,
  который сам является производным от java.util.EventObject. Любой бин может прослушивать события, реализовав интерфейс
  ApplicationListener<T>, причем его не нужно регистрировать в ApplicationContext, это делается автоматически (а в других контекстах что??). В
  интерфейсе ApplicationListener определен лишь один метод onApplicationEvent(T event), который вызывается в момент,
  когда событие сгенерировано.
  Пояснение примера в com.kraynov.ch5.event.*: клиент получает ссылку на бин publisher и посылает запрос на публикацию
   сообщения. Publisher реализует интерфейс ApplicationContextAware, поэтому имеет ссылку на экземпляр
   ApplicationContext. Ему и делегируется запрос на публикацию конкретного ApplicationEvent. ApplicationContext имеет
   доступ к зарегистрированным листенерам. По типу ApplicationEvent он определяет листенеры, которые должны
   отреагировать на публикацию.
 Доступ к ресурсам - com.kraynov.ch5.resource.ResourceDemo
  Spring предоставляет унифицированный механизм для доступа к разного рода ресурсам независимо от протокола доступа, и
  от того, где он находится - в файловой системе, в classpath или на удаленном сервере.
  Интерфейс org.springframework.core.io.Resource является ключевым. Основные реализации - FileSystemResource, UrlResource,
  ClassPathResource. Для поиска и создания экземпляров Resource платформа использует другой интерфейс ResourceLoader и
  его стандартную имплементацию DefaultResourceLoader. Обычно достаточно использовать ApplicationContext в качестве
  реализации ResourceLoader.

Конфигурация, используюзая Java-классы - com.kraynov.ch5.javaconfig.*
  Кроме XML для конфигурирования ApplicationContext можно использовать Java-классы.
 Конфигурирование ApplicationContext в Java
  Класс com.kraynov.ch5.javaconfig.AppConfig является простейшей реализацией конфигурирования AC через Java-классы.
  Рассмотрим, какие аннотации применяются в этом классе.

      @Configuration //применяется к типу, сообщает платформе Spring о том, что это конфигурационный файл, основанный на java.
      public class AppConfig {

      @Bean //применяется к методам, а также к ANNOTATION_TYPE, эквивалентна декскриптору <bean>
      //Вызов render.setMessageProvider(messageProvider()) эквивалентен применению дескриптора <ref>
      //XML
      // <bean id="messageRenderer" class="com.kraynov.ch5.javaconfig.StandartOutMessageRenderer">
      //     <property name="messageProvider" ref="messageProvider"/>
      // </bean>
      public MessageRenderer messageRenderer(){
        ...
        render.setMessageProvider(messageProvider());
        ...
      }

  Другие аннотации, применимые здесь:
  @PropertySource используется для загрузки файлов свойств в AppCtx, принимает в качестве аргумента местоположегие.
   Аналогично <context:property-placeholder> в XML.
  @Import позволяет импортировать другие класс конфигурации, т.о. можно иметь множество Java-классов конфигурации,
   например один для бинов DAO, один - для объявление бинов служю и тд.
  @ComponentScan определяет пакеты, которые Spring должна сканировать на предмет аннотаций для определений бинов.
   Аналогично <context:component-scan> в XML.
  @Scope определяет область действия бина
  @Lazy заставляет Spring создавать экземпляры бина только при его запрашивании. Аналогично lazy-init=true в XML.

Профили - com.kraynov.ch5.profile.*
  Часто, хочется иметь архив приложения, который может работать без перекомплиляции как на продакшен-сервере, так и на
  тестовом окружении. Также зачастую AppCtx должен быть сконфигурирован различным образом на разных окружениях.
  Концепция профилей позволяет вынести решение о том, каким образом будет сконфигурирован AppCtx за пределы самого
  приложения, например с помощью аргумента JVM.
  Поддержка профилей Spring позволяет иметь один архив приложения и развертывать его в различных средах, передавая
  подходящие профили в качестве аргумента во время начальной загрузки JVM.
  Пояснение примера в com.kraynov.ch5.profile.*: имеется две имплементации FoodProviderService - для десткого сада и для
   школы. Каждый из них используется в отдельной конфигурации - kindergarten-config.xml и highschool-config.xml. Каждая
   из конфигураций имеет заполненный атрибут profile: <beans ... profile="highschool">. В результате при загрузке AppCtx
   обеими конфигурациями активной будет только та, которая соответствует профилю, который в примере задается программно,
   но может быть задан например как параметр JVM. Программная активация профиля:
          ctx.getEnvironment().setActiveProfiles("kindergarten");

  Профили можно применять и в java-конфигурациях: для этого предназначена аннотация @Profile, применимая к типам. Пример:
          @Configuration
          @Profile(value="kindergarten")
          public class KindergartenConfig{...}

Абстракции Environment и PropertySource - com.kraynov.ch5.env
  Интерфейс Environment представляет собой еще один уровень абстракции, который предназначен для инкапсуляции среды
  выполняющегося Spring-приложения. Кроме профилей, он также инкапсулирует свойства (свойства служат для сохранения
  конфигурации среды, например местоположение папки приложения, параметры подключения к бд и тд.).
  Абстракции Environment и PropertySource подгружаются во время начальной загрузки ApplicationContext.
  Пояснение примера в com.kraynov.ch5.env.EnvironmentSample: получаем ссылку на интерфейс ConfigurableEnvironment. Через
   этот интерфейс получается обработчик MutablePropertySources (стандартная реализация интерфейса PropertySources,
   которая позволяет манипулировать содержащимися источниками свойств). Затем создается карта, помещается в нее свойства
   приложения и конструируется экземпляр класса MapPropertySource(подкласс PropertySource, который читает ключи и
   значения из Map) для этой карты. Наконец добавляеся класс экземпляр MapPropertySource к MutablePropertySources.
  По умолчанию в рамках абстракции PropertySource платформа Spring обращается в свойствам в следующем порядке:
        свойства системы для выолняющейся JVM
        переменные среды
        свойсва, определяемый приложением.
  Тем не менее, Spring позволяет управлять порядком, в соответствие с которым будут извлекаться свойства.
  В реальных приложениях необходимость в непосредственном взаимодействии с интерфейсом Environment возникает редко. Чаще
  всего будет использоваться заоплнитель свойства в форме ${application.home} и внедрение полученного свойства в бины.

Конфигурация, использующая аннотации JSR-330
  В JЕЕ 6 предлагается поддержка спеuификаuии JSR-330 ("Dependency lnjection for Java" - "Внедрение зависимостей для
  Java"), которая представляет собой коллекцию аннотаций для выражения конфигурации DI приложения внутри контейнера JEE
  или другой совместимой инфраструктуры loC.
  Платформа Spring также поддерживает и распознает эти аннотации, так что хотя вы не можете запускать приложение в
  контейнере JEE 6, все равно имеете возможность применять аннотации JSR-330 в рамках Spring.
      @Named - служит для связи поля, в которое происходит внедрение, и класса, экземпляр которого нужно внедрять.
      Свойство value указывает на имя бина, аналогично атрибуту name дескриптора <bean>.
      Аналоги в Spring: @Component и @Service.
      @Inject - служит для указания необходимости внедрения. Применимо к методу, конструктору, свойству.
      @Singleton - по умолчанию в JEE бин не является одиночным в отличие от Spring.
  Для работы с JSR-330 не нужны какие-то специальные дескрипторы (все в аннотациях).

Конфигурация, использующая Groovy
  В 4ой версии Spring добавлена возможность конфигурирования бинов с использованием языка Groovy.
  Код в стрим решил не вносить.






