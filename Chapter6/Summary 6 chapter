Глава 6 (глава 5 в версии Spring 4) - Введение в аспектно-ориентированное программирование с использованием Spring

    Аспектно-ориентированное программивароние (АОП, AOP) - некая парадигма, в основе которой лежит идея максимально
    разделить код. На АОП часто ссылаются как на инструмент сквозной функциональности, нечто похожее на пробрасывание
    Exception. Типичными примерами сквозной функциональности является логирование. Важно понимать, что АОП дополняет ООП
    и помогает решить задачи определенных классов, которые плохо решаются в рамках ООП.

 Концепции АОП

   Термины:
    Точки соединения (joinpoint) - конкретнейшая точка во время выполнения программы: обращение к методу, вызов метода,
     инициализация класса, создание экземпляра.
    Советы (advice) - фрагмент кода, который может выполниться. Совет может быть выполнен до, после или вместо точки
     соединения.
    Срезы (англ. pointcut) — набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному
     совету. По сути набор условий.
    Аспект (англ. aspect) — комбинация совета и срезов, инкапсулированных в классе.
     Аспект это Модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода,
     применяя совет в точках соединения, определённых некоторым срезом.
        aspect VisitAspect {
          void Point.acceptVisitor(Visitor v) {
            v.visit(this);
          }
        }

    Связывание (weaving) - процесс вставки аспектов в точки соединения. Существует три типа - во время компиляции и
     сборки, во время выполнения, либо во время загрузки (load-time weaving - LTW), при котором перехватывается
     лежащий в основе загрузчик классов JVM и обеспечивает связывание с байт-кодом, когда он загружается загрузчиком.

 Типы АОП
   Различают два типа АОП: статическое и динамическое.
   При статическомм АОП процесс связывания формирует еще один шаг внутри процесса сборки приложения. Т.е.
   предусматривается модификация действительного байткода приложения. Конечным результатом является просто байткод.
   Для добавления функциональности к цели придется пересобирать все приложение. Реализация - AspectJ.
   AspectJ - аспектно-ориентированное расширение языка Java.

   Динамические реализции АОП (в Spring именно динамическая реализация) напротив производят связывание в рантайме. В
   Spring это достигается путем создания Proxy. Недостатком является производительность. Преимущество - не надо
   пересобирать приложение.

 Архитектура АОП в Spring
   Основана на прокси. При снабжении советом экземпляр класса, движок создает прокси-объект (а для него генерит класс).
   Этому объекту затем и направляются все вызовы. При получении вызова, он анализирует текущие условия (срез) и
   свзяывает подходящий совет. Внутренее Spring поддерживает две реализации прокси: динамический прокси JDK и прокси
   CGLIB. Первая изпользуется по умолчанию, если целевой объект реализует интерфейс. В противном случае CGLIB.
   В Spring поддерживается только один тип точек соединения - Method Invocation.
   Аспект в Spring это класс, реализующий интерфейс Advisor. Существуют несколько готовых реализаций. Можно создать свою.
   Подчиненный интерфейс - PointcutAdvisor. Стандартная реализация - DefaultPointcutAdvisor - конфигурирует со срезом,
   который по умолчанию включает все методы.

 Прокси АОП в Spring
   Класс ProxyFactory управляет процессом связывания и создания прокси в Spring. Под капотом имеет место цепочка делегирования:
   ProxyFactory -> DefaultAopProxyFactory -> JdkDynamicAopProxy/Cglib2AopProxy.
   Платформа Spring поддерживает 6 типов советов, для каждого из них свой интерфейс:
        Перед               before              org.springframework.aop.MethodBeforeAdvice
        После возврата      after returning     org.springframework.aop.AfterReturningAdvice
        После               after finally       org.springframework.aop.AfterAdvice
        Вместо              around              org.aopalliance.intercept.MethodInterceptor
        Перехват            throws              org.springframework.aop.ThrowAdvice
        Введение            introduction        org.springframework.aop.IntroductionInterceptor

 Совет before - имеет полный доступ к цели Method Invocation, может менять аргументы, переданные методу, но не имеет
  контроля выполнения самого метода, как и возвращаемого значения. Сигнатура:
         public void before(Method method, Object[] objects, Object o) throws Throwable {

 Совет after returning - имеет доступ к цели Method Invocation, аргументам, а также к возвращаемому значению.
  Изменять аргументы не может, контроля выполнения метода не имеет; изменять возврщаемое значение также не может, но
  может бросить исключение, которое будет передано наверх.
  Если целевой метод генерирует исключение, то совет не выполняется. Сигнатура:
         public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {

 Совет around - имеет доступ к цели, аргументам, возвращаемому значению. Является комбинацией предыдущих двух советов.
  Возможность изменять аргументы, возвращаемое значение, а также возможность вовсе не выполнять исходный метод.
  Удаленные прокси и управление транзакциями реализована с помощью такого совета. Сигнатура:
         public Object invoke(MethodInvocation methodInvocation) throws Throwable {

 Совет throws - вызывается после возврата из метода только в случае, если бы сгенерировано исключение. Совет этого типа
  может перехватывать только специфичные исключения, и тогда возможен доступ к методу, сгенерировавшему исключение,
  к аргументам, переданным вызову, и к цели вызова. При использовании совета "перехват" нельзя проиrнорировать возникшее
  исключение и взамен возвратить какое-то значение. Единственная модификация, которую можно внести в поток управления
  программы, заключается в изменении типа сгенерированного исключения.
  В отличие от других интерфейсов в ThrowsAdvice не определено ни одного метода; он просто является маркерным
  интерфейсом, применяемым платформой Spring. Используется рефлексия. Сигнатуры:
         public void afterThrowing(Exception ex) throws Throwable{
         public void afterThrowing(Method method, Object[] args, Object target, NullPointerException ex) throws Throwable{

  Первое, что Spring ищет для совета "перехват" - это один или более открытых методов по имени afterThrowing ().
  Возвращаемый тип этих методов не важен, но лучше указывать void. Первый метод afterThrowing() принимает единственный
  аргумент типа Exception. В нем можно указывать любой тип исключения, и этот метод идеально подходит, когда вас не
  интересует метод, сгенерировавший исключение, или переданные ему аргументы. Этот метод перехватывает Exception и любые
  подтипы Exception, если только для них не предусмотрены собственные методы afterThrowing().
  Во втором методе afterThrowing () мы объявили четыре аргумента для указания метода, сгенерировавшего исключение,
  аргументов, переданных этому методу, и цели вызова метода. Порядок следования аргументов в этом методе важен, и они
  должны быть указаны все четыре. Стоит обратить внимание, что второй метод afterThrowing() перехватывает исключения
  типа NullPointerException (или его подтипа).

Советы и срезы в Spring
  При добавлении совета на самом деле Spring создает объект аспекта (interface Advisor), используя имплементацию
  DefaultPointcutAdvisor, в который помещает объект совета (interface Advice) и объект среза (interface Pointcut)
  По умолчанию используется срез Pointcut.TRUE = TruePointcut.INSTANCE, который указывает на все методы.
  Интерфейс Pointcut определяет два метода:
        public interface Pointcut {
            ClassFilter getClassFilter();
            MethodМatcher getMethodМatcher();
        }

        public interface ClassFilter {
            boolean matches(Class<?> clazz);
        }

        public interface MethodМatcher {
            boolean matches(Method m, Class<?> targetClass);
            boolean isRuntime();
            boolean matches(Method m, Class<?> targetClass, Object[] args);
        }

  При выяснении, применим ли данный Pointcut к конкретному методу, Spring сначала проверяет, применим ли Pointcut к
  классу этого метода, используя экземпляр ClassFilter. Затем проверяет, применим ли Pointcut к самому методу, используя
  экземпляр MethodМatcher.
  В Spring поддерживаются два типа MethodMatcher, статический и динамический, что определяется вызовом метода isRuntime().
  Для статического среза Spring вызывает метод matches (Method, Class<T>) по одному разу для каждого метода целевого
  объекта, кешируя возвращаемое значение для последующих обращений к этому методу. Таким образом, проверка применимости
  метода производится только однократно для каждого метода, и последующие обращения к методу не приводят к вызову.
  Для динамических срезов Spring по-прежнему выполняет статическую проверку с помощью matches (Method, Class<T>) при
  вызове метода в первый раз, чтобы определить общую применимость этого метода. Однако в дополнение к этому и
  при условии, что статическая проверка возвратила true, платформа Spring проводит дальнейшую проверку для каждого
  вызова метода, используя matches (Method, Class<T>, Object[] ). Таким образом, динамический MethodМatcher может
  выяснить, должен ли применяться срез, на основе конкретного вызова метода, а не только самого метода. Например, срез
  необходимо применять, только если аргумент представляет собой значение типа Integer, которое больше 100. В этом случае
  в методе matches (Method, Class<T>, Object[] ) может быть предусмотрен код для дополнительной проверки аргумента при
  каждом вызове.
  В spring4 основные готовые реализации интерфейса Pointcut покрывают большое количество кейсов.

  1) Класс ControlFlowPointcut представляет срез, предназначенный для специального случая, который соответствует всем
  методам в потоке управления другого метода - т.е . любому методу, который вызван прямо или косвенно в результате
  выполнения другого метода. В 10-15 раз медленее чем обычная проверка.
     public class ControlFlowPointcut implements Pointcut, ClassFilter, MethodMatcher

  2) Класс ComposablePointcut применяется для объединения двух и более срезов с помощью таких операций, как union() и
  intersection()

