Глава 6 (глава 5 в версии Spring 4) - Введение в аспектно-ориентированное программирование с использованием Spring

    Аспектно-ориентированное программивароние (АОП, AOP) - некая парадигма, в основе которой лежит идея максимально
    разделить код. На АОП часто ссылаются как на инструмент сквозной функциональности, нечто похожее на пробрасывание
    Exception. Типичными примерами сквозной функциональности является логирование. Важно понимать, что АОП дополняет ООП
    и помогает решить задачи определенных классов, которые плохо решаются в рамках ООП.

 Концепции АОП

   Термины:
    Точки соединения (joinpoint) - конкретнейшая точка во время выполнения программы: обращение к методу, вызов метода,
     инициализация класса, создание экземпляра.
    Советы (advice) - фрагмент кода, который может выполниться. Совет может быть выполнен до, после или вместо точки
     соединения.
    Срезы (англ. pointcut) — набор точек соединения. Срез определяет, подходит ли данная точка соединения к данному
     совету. По сути набор условий.
    Аспект (англ. aspect) — комбинация совета и срезов, инкапсулированных в классе.
     Аспект это Модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода,
     применяя совет в точках соединения, определённых некоторым срезом.
        aspect VisitAspect {
          void Point.acceptVisitor(Visitor v) {
            v.visit(this);
          }
        }

    Связывание (weaving) - процесс вставки аспектов в точки соединения. Существует три типа - во время компиляции и
     сборки, во время выполнения, либо во время загрузки (load-time weaving - LTW), при котором перехватывается
     лежащий в основе загрузчик классов JVM и обеспечивает связывание с байт-кодом, когда он загружается загрузчиком.

 Типы АОП
   Различают два типа АОП: статическое и динамическое.
   При статическомм АОП процесс связывания формирует еще один шаг внутри процесса сборки приложения. Т.е.
   предусматривается модификация действительного байткода приложения. Конечным результатом является просто байткод.
   Для добавления функциональности к цели придется пересобирать все приложение. Реализация - AspectJ.
   AspectJ - аспектно-ориентированное расширение языка Java.

   Динамические реализации АОП (в Spring именно динамическая реализация) напротив производят связывание в рантайме. В
   Spring это достигается путем создания Proxy. Недостатком является производительность. Преимущество - не надо
   пересобирать приложение.

 Архитектура АОП в Spring
   Основана на прокси. При снабжении советом экземпляр класса, движок создает прокси-объект (а для него генерит класс).
   Этому объекту затем и направляются все вызовы. При получении вызова, он анализирует текущие условия (срез) и
   свзяывает подходящий совет. Внутренее Spring поддерживает две реализации прокси: динамический прокси JDK и прокси
   CGLIB. Первая изпользуется по умолчанию, если целевой объект реализует интерфейс. В противном случае CGLIB.
   В Spring поддерживается только один тип точек соединения - Method Invocation.
   Аспект в Spring это класс, реализующий интерфейс Advisor. Существуют несколько готовых реализаций. Можно создать свою.
   Подчиненный интерфейс - PointcutAdvisor. Стандартная реализация - DefaultPointcutAdvisor - конфигурирует со срезом,
   который по умолчанию включает все методы.

 Прокси АОП в Spring
   Класс ProxyFactory управляет процессом связывания и создания прокси в Spring. Под капотом имеет место цепочка делегирования:
   ProxyFactory -> DefaultAopProxyFactory -> JdkDynamicAopProxy/Cglib2AopProxy.
   Платформа Spring поддерживает 6 типов советов, для каждого из них свой интерфейс:
        Перед               before              org.springframework.aop.MethodBeforeAdvice
        После возврата      after returning     org.springframework.aop.AfterReturningAdvice
        После               after finally       org.springframework.aop.AfterAdvice
        Вместо              around              org.aopalliance.intercept.MethodInterceptor
        Перехват            throws              org.springframework.aop.ThrowAdvice
        Введение            introduction        org.springframework.aop.IntroductionInterceptor

 Совет before - имеет полный доступ к цели Method Invocation, может менять аргументы, переданные методу, но не имеет
  контроля выполнения самого метода, как и возвращаемого значения. Сигнатура:
         public void before(Method method, Object[] objects, Object o) throws Throwable {

 Совет after returning - имеет доступ к цели Method Invocation, аргументам, а также к возвращаемому значению.
  Изменять аргументы не может, контроля выполнения метода не имеет; изменять возврщаемое значение также не может, но
  может бросить исключение, которое будет передано наверх.
  Если целевой метод генерирует исключение, то совет не выполняется. Сигнатура:
         public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {

 Совет around - имеет доступ к цели, аргументам, возвращаемому значению. Является комбинацией предыдущих двух советов.
  Возможность изменять аргументы, возвращаемое значение, а также возможность вовсе не выполнять исходный метод.
  Удаленные прокси и управление транзакциями реализована с помощью такого совета. Сигнатура:
         public Object invoke(MethodInvocation methodInvocation) throws Throwable {

 Совет throws - вызывается после возврата из метода только в случае, если бы сгенерировано исключение. Совет этого типа
  может перехватывать только специфичные исключения, и тогда возможен доступ к методу, сгенерировавшему исключение,
  к аргументам, переданным вызову, и к цели вызова. При использовании совета "перехват" нельзя проиrнорировать возникшее
  исключение и взамен возвратить какое-то значение. Единственная модификация, которую можно внести в поток управления
  программы, заключается в изменении типа сгенерированного исключения.
  В отличие от других интерфейсов в ThrowsAdvice не определено ни одного метода; он просто является маркерным
  интерфейсом, применяемым платформой Spring. Используется рефлексия. Сигнатуры:
         public void afterThrowing(Exception ex) throws Throwable{
         public void afterThrowing(Method method, Object[] args, Object target, NullPointerException ex) throws Throwable{

  Первое, что Spring ищет для совета "перехват" - это один или более открытых методов по имени afterThrowing ().
  Возвращаемый тип этих методов не важен, но лучше указывать void. Первый метод afterThrowing() принимает единственный
  аргумент типа Exception. В нем можно указывать любой тип исключения, и этот метод идеально подходит, когда вас не
  интересует метод, сгенерировавший исключение, или переданные ему аргументы. Этот метод перехватывает Exception и любые
  подтипы Exception, если только для них не предусмотрены собственные методы afterThrowing().
  Во втором методе afterThrowing () мы объявили четыре аргумента для указания метода, сгенерировавшего исключение,
  аргументов, переданных этому методу, и цели вызова метода. Порядок следования аргументов в этом методе важен, и они
  должны быть указаны все четыре. Стоит обратить внимание, что второй метод afterThrowing() перехватывает исключения
  типа NullPointerException (или его подтипа).

Советы и срезы в Spring
  При добавлении совета на самом деле Spring создает объект аспекта (interface Advisor), используя имплементацию
  DefaultPointcutAdvisor, в который помещает объект совета (interface Advice) и объект среза (interface Pointcut)
  По умолчанию используется срез Pointcut.TRUE = TruePointcut.INSTANCE, который указывает на все методы.
  Интерфейс Pointcut определяет два метода:
        public interface Pointcut {
            ClassFilter getClassFilter();
            MethodМatcher getMethodМatcher();
        }

        public interface ClassFilter {
            boolean matches(Class<?> clazz);
        }

        public interface MethodМatcher {
            boolean matches(Method m, Class<?> targetClass);
            boolean isRuntime();
            boolean matches(Method m, Class<?> targetClass, Object[] args);
        }

  При выяснении, применим ли данный Pointcut к конкретному методу, Spring сначала проверяет, применим ли Pointcut к
  классу этого метода, используя экземпляр ClassFilter. Затем проверяет, применим ли Pointcut к самому методу, используя
  экземпляр MethodМatcher.
  В Spring поддерживаются два типа MethodMatcher, статический и динамический, что определяется вызовом метода isRuntime().
  Для статического среза Spring вызывает метод matches (Method, Class<T>) по одному разу для каждого метода целевого
  объекта, кешируя возвращаемое значение для последующих обращений к этому методу. Таким образом, проверка применимости
  метода производится только однократно для каждого метода, и последующие обращения к методу не приводят к вызову.
  Для динамических срезов Spring по-прежнему выполняет статическую проверку с помощью matches (Method, Class<T>) при
  вызове метода в первый раз, чтобы определить общую применимость этого метода. Однако в дополнение к этому и
  при условии, что статическая проверка возвратила true, платформа Spring проводит дальнейшую проверку для каждого
  вызова метода, используя matches (Method, Class<T>, Object[] ). Таким образом, динамический MethodМatcher может
  выяснить, должен ли применяться срез, на основе конкретного вызова метода, а не только самого метода. Например, срез
  необходимо применять, только если аргумент представляет собой значение типа Integer, которое больше 100. В этом случае
  в методе matches (Method, Class<T>, Object[] ) может быть предусмотрен код для дополнительной проверки аргумента при
  каждом вызове.
  Платформа Spring предлагает мощный набор реализаций Pointcut, которые должны удовлетворять большинству, если не всем,
  требованиям приложения. Основные готовые реализации интерфейса Pointcut в Spring4 покрывают большое количество кейсов.
  Далее описание всех 8ми.

  1) Класс ControlFlowPointcut представляет срез, предназначенный для специального случая, который соответствует всем
  методам в потоке управления другого метода - т.е . любому методу, который вызван прямо или косвенно в результате
  выполнения другого метода. В 10-15 раз медленее чем обычная проверка.
     public class ControlFlowPointcut implements Pointcut, ClassFilter, MethodMatcher

  2) Класс ComposablePointcut применяется для объединения двух и более срезов с помощью таких операций, как union() и
  intersection().
     public class ComposablePointcut implements Pointcut, Serializable

  3) Класс StaticMethodМatcherPointcut служит базовым классом для построения статических срезов. Поскольку класс
  расширяет класс StaticMethodMatcher (также абстрактный), который реализует интерфейс MethodMatcher, потребуется
  реализовать метод matches (Method, Class<?>). При необходимости можно переопределить метод ClassFilter getClassFilter()
     public abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher implements Pointcut

  4) Класс DynamicMethodМatcherPointcut служит базовым классом для построения динамических срезов. Позволяет производить
  динамические проверки, например проверить значение аргумента.
  Динамические проверки обеспечивают более высокую гибкость, чем статические проверки, но из-за дополнительных накладных
  расходов во время выполнения они должны использоваться только в случае абсолютной необходимости.
     public abstract class DynamicMethodMatcherPointcut extends DynamicMethodMatcher implements Pointcut

  5) С помощью класса NameMatchМethodPointcut можно создать срез, который выполняет простое сопоставление со списком
  имен методов - часто при создании среза требуется выполнять сопоставление на основе лишь имени метода, игнорируя его
  сигнатуру и возвращаемый тип. В таком случае можно избежать создания подкласса StaticMethodMatcherPointcut и
  применять вместо него NameMatchMethodPointcut (подкласс StaticMethodMatcherPointcut) для сопоставления со списком
  имен методов. Хранит внутри себя List<String> с именами методов.
     public class NameMatchMethodPointcut extends StaticMethodMatcherPointcut implements Serializable
  Использование:
     NameMatchMethodPointcut рc = new NameMatchMethodPointcut();
     рc.addMethodName("foo");
     рc.addMethodName("bar");

  6) Класс JdkRegexpMethodPointcut позволяет определять срезы с использованием поддержки регулярных выражений JDK 1.4.
  Этот класс требует JDK 1.4 или более новой версии. Сожержит два массива паттернов, один на включение, другой на исключение
     public class JdkRegexpMethodPointcut extends AbstractRegexpMethodPointcut
  Использование:
     JdkRegexpMethodPointcut ре = new JdkRegexpMethodPointcut();
     pc.setPattern(".*foo.*");

  7) Класс AspectJExpressionPointcut повзоляет определять срезы AspectJExpressionPointcut для определения срезов
  посредством языка выражений AspectJ. При объявлении среза в ХМL-конфигурации с использованием пространства имен аор,
  либо при определении среза через аннотации @AspectJ, платформа Spring по умолчанию применяет язык срезов AspectJ.
     public class AspectJExpressionPointcut extends AbstractExpressionPointcut
     		implements ClassFilter, IntroductionAwareMethodMatcher, BeanFactoryAware {
  Использование:
     AspectJExpressionPointcut ре = new AspectJExpressionPointcut();
     pc.setExpression("execution(* foo*( .. ))"); //совет должен применяться к выполнению любых методов, которые имеют
                //имена, начинающиеся с foo, принимают любые аргументы и возвращают значение любого типа

  8) Класс AnnotationМatchingPointcut позволяет определять срезы с использованием собственных аннотаций.
     public class AnnotationMatchingPointcut implements Pointcut

  Чтобы использовать аннотации, нужно определить свою аннотацию, затем пометить ей необходимые методы или классы,
  затем создать pointcut.

  Использование:
     //Определяем интерфейс аннотации, используемой для объявления среза
     @Retention(RetentionPolicy.RUNTIME)
     @Target({ElementType.TYPE, ElementType.METHOD})
     puЬlic @interface AdviceRequired {
     }

     //Далее помечаем нашей аннотацией метод
     @AdviceRequired
     public void foo(int х) {
        System.out.println("Invoked foo() with: " +х);
     }

  Если не удается найти срез, подходящий для ваших потребностей, вы можете создать собственную реализацию с нуля,
  реализовав интерфейсы Pointcut, MethodMatcher и ClassFilter.

Что собой представляют прокси
 Функции, возвложенные на прокси
  Spring доступны два типа прокси: nрокси JDK, создаваемые с использованием класса Proxy из JDK, и прокси на основе CGLIВ,
  создаваемые с помощью класса Enhancer из CGLIВ.
  Прокси можно сконфигурировать так, чтобы он был доступен через класс AopContext (который является абстрактным); это
  позволит извлечь прокси и вызвать оснащенные советом методы из целевого объекта.
  Прокси отвечает за обеспечение доступности класса прокси, если эта опция включена с помощью ProxyFactory.setExposeProxy().
  В дополнение к этому все классы прокси по умолчанию реализуют интерфейс Advised, который, помимо прочего, позволяет
  изменять цепочку совета после того, как прокси был создан. Прокси должен также гарантировать, чтобы любой метод,
  который возвращает this (т.е. возвращает цель с прокси), фактически возвращал прокси, а не целевой объект.
 Использование динамических прокси JDK
  В отличие от прокси CGLIВ, прокси JDK могут генерироваться только для интерфейсов, но не классов. Таким образом,
  любой объект, для которого необходим прокси, должен реализовывать хотя бы один интерфейс.
  При использовании прокси JDK все вызовы методов перехватываются JVМ и направляются методу invoke() прокси. Затем invoke()
  выясняет, снабжен ли вызываемый метод советом (согласно правилам, определяемым срезом), и если это так, вызывает цепочку
  совета и сам метод с помощью рефлексии. Вдобавок метод invoke() выполняет всю логику, которая обсуждалась в предыдущем разделе.
  Прокси JDK не разделяет методы на снабженные и не снабженные советом вплоть до вызова метода invoke(). Другими словами,
  метод invoke() вызывается абсолютно для всех методов проксируемого класса. При каждом вызове метода возникают накладные
  расходы времени выnолнения (рефлексия), хотя часто прокси не реализует никакой дополнительной обработки кроме вызова
  через рефлексию метода, не снабженного советом. Чтобы сообщить proxyFactory о необходимости использования прокси JDK,
  необходимо указать список интерфейсов для прокси с помощью метода setInterfaces() (в классе AdvisedSupport, который
  класс ProxyFactory косвенно расширяет).
 Использование прокси CGLIB
  В случае прокси JDK все решения относительно обработки конкретного вызова метода принимаются во время выполнения при
  каждом таком вызове. Библиотека CGLIB динамически генерирует байт-код нового класса для каждого прокси, по возможности
  повторно используя ранее сгенерированные классы. Прокси CGLIB генерирует соответствующий байт-код для вызова любых
  методов, не снабженных советом, напрямую, сокращая накладные расходы, привносимые прокси. Вдобавок прокси CGLIВ
  определяет, может ли метод возвращать this, и если нет, то позволяет вызову метода выполняться напрямую, снова
  сокращая накладные расходы времени выполнения. Есть возможность поддержки цепочки фиксированных советов - цепочки,
  которая не будет меняться после сохдания прокси. В фиксированном режиме прокси CGLIB цепочка совета не может быть
  изменена и CGLIВ проводит дополнительную оптимизацию.

Введения (introductions)
  За счет использования введений можно динамически добавлять новую функциональность к существующему объекту. Платформа
  Spring позволяет вводить в существующий объект реализацию любого интерфейса.
  В Spring введения трактуются как специальный тип совета, точнее - как специальный тип совета "вокруг". Поскольку
  введения применяются исключительно на уровне классов, использовать срезы с введениями нельзя.
  Введение создается путем реализации интерфейса IntroductionInterceptor, который расширяет интерфейсы
  Methodinterceptor и DynamicintroductionAdvice.
      public interface IntroductionInterceptor extends MethodInterceptor, DynamicIntroductionAdvice
  Spring предоставляет стандартную реализацию IntroductionInterceptor по имени DelegatingIntroductionInterceptor.

  Для добавления введений к прокси потребуется применять IntroductionAdvisor. Стандартной реализацией IntroductionAdvisor
  является DefaultIntroductionAdvisor, которая должна удовлетворять большинству, если не всем, потребностям введения.
  Введение формирует часть состояния объекта, в результате чего для каждого такого объекта должен быть предусмотрен
  отдельный экземпляр совета. Это называется жизненным циклом на основе экземпляров в противовес жизненному циклу на основе
  классов в случае обычных советов.

 com.kraynov.ch6.introductions.*
  Примером использования введения может служить задача отслеживания, изменился ли объект. Пусть есть класс TargetBean, у которого есть поле name,
  вводится интерфейс IsModified. Далее создаетя класс смеси (mixin), реализующий интерфейс и отнаследованный от
  Delegatingintroductioninterceptor, в котором реализуется вся логика по отслеживанию изменений. Смесь вводит в объект
  не только методы, но также и состояние - поле isModified. Именно поэтому один экземпляр введения может использоваться
  только в одном экземпляре. В смеси можно реализовать произвольное количество интерфейсов, и каждый из них будет
  автоматически введен в объект, снабженный советом.
  На следующем шаге создается класс аспекта Advisor, служащий оболочкой для создания класса смеси. Этот шаг не обязателен,
  но он поможет обеспечить применение нового экземпляра класса смеси для каждого объекта, снабженного советом.

  Введения ямяются одним из наиболее мощных средств АОП в Spring; они позволяют не только расширять функциональность существующих
  методов, но также динамически расширять набор интерфейсов и реализаций объектов. Использование введений - это великолепный
  способ реализации сквозной логики, с которой приложение взаимодействует через четко определенные интерфейсы. В общем, это
  такая разновидность логики, которую желательно применять декларативно, а не программно.

Декларативное конфигурирование АОП
  Для декларативного конфигурирования АОП в Spring доступны три опции.
   Использование ProxyFactoryBean.
   Использование пространства имен аор в Spring.
   Использование аннотация в стиле @AspectJ.

  ProxyFactoryBean
  Поскольку с ProxyFactoryBean можно использовать совет и аспект, декларативное конфигурирование доступно не только для совета,
  но также и для срезов.